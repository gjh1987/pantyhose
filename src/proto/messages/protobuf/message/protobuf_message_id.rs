// Generated by proto-id-tool
// DO NOT EDIT MANUALLY

use crate::framework::data::DynamicBuffer;
use crate::proto::messages::{MessageId, MessageIdSerialize};
use prost::Message;

// Message IDs
pub const MSG_ID_CHAT_TEST_B_REQUEST: u16 = 1;
pub const MSG_ID_CHAT_TEST_B_RESPONSE: u16 = 2;
pub const MSG_ID_SERVER_CONFIG: u16 = 3;
pub const MSG_ID_NODE_REGISTER_B_REQUEST: u16 = 4;
pub const MSG_ID_NODE_REGISTER_B_RESPONSE: u16 = 5;
pub const MSG_ID_NODE_CONNECT_B_REQUEST: u16 = 6;
pub const MSG_ID_NODE_CONNECT_B_RESPONSE: u16 = 7;
pub const MSG_ID_NODE_REGISTER_B_NOTIFY: u16 = 8;
pub const MSG_ID_RPC_MESSAGE_F_REQUEST: u16 = 9;
pub const MSG_ID_RPC_MESSAGE_F_RESPONSE: u16 = 10;
pub const MSG_ID_RPC_MESSAGE_F_NOTIFY: u16 = 11;
pub const MSG_ID_RPC_FORWARD_MESSAGE_B_REQUEST: u16 = 12;
pub const MSG_ID_RPC_FORWARD_MESSAGE_B_RESPONSE: u16 = 13;
pub const MSG_ID_RPC_FORWARD_MESSAGE_B_NOTIFY: u16 = 14;
pub const MSG_ID_BASE_MESSAGE: u16 = 15;
pub const MSG_ID_SERIAL_MESSAGE: u16 = 16;
pub const MSG_ID_LOGIN_F_REQUEST: u16 = 17;
pub const MSG_ID_LOGIN_F_RESPONSE: u16 = 18;

impl MessageId for super::chat::ChatTestBRequest {
    fn msg_id(&self) -> u16 {
        MSG_ID_CHAT_TEST_B_REQUEST
    }
}

impl MessageId for super::chat::ChatTestBResponse {
    fn msg_id(&self) -> u16 {
        MSG_ID_CHAT_TEST_B_RESPONSE
    }
}

impl MessageId for super::cluster::ServerConfig {
    fn msg_id(&self) -> u16 {
        MSG_ID_SERVER_CONFIG
    }
}

impl MessageId for super::cluster::NodeRegisterBRequest {
    fn msg_id(&self) -> u16 {
        MSG_ID_NODE_REGISTER_B_REQUEST
    }
}

impl MessageId for super::cluster::NodeRegisterBResponse {
    fn msg_id(&self) -> u16 {
        MSG_ID_NODE_REGISTER_B_RESPONSE
    }
}

impl MessageId for super::cluster::NodeConnectBRequest {
    fn msg_id(&self) -> u16 {
        MSG_ID_NODE_CONNECT_B_REQUEST
    }
}

impl MessageId for super::cluster::NodeConnectBResponse {
    fn msg_id(&self) -> u16 {
        MSG_ID_NODE_CONNECT_B_RESPONSE
    }
}

impl MessageId for super::cluster::NodeRegisterBNotify {
    fn msg_id(&self) -> u16 {
        MSG_ID_NODE_REGISTER_B_NOTIFY
    }
}

impl MessageId for super::cluster::RpcMessageFRequest {
    fn msg_id(&self) -> u16 {
        MSG_ID_RPC_MESSAGE_F_REQUEST
    }
}

impl MessageId for super::cluster::RpcMessageFResponse {
    fn msg_id(&self) -> u16 {
        MSG_ID_RPC_MESSAGE_F_RESPONSE
    }
}

impl MessageId for super::cluster::RpcMessageFNotify {
    fn msg_id(&self) -> u16 {
        MSG_ID_RPC_MESSAGE_F_NOTIFY
    }
}

impl MessageId for super::cluster::RpcForwardMessageBRequest {
    fn msg_id(&self) -> u16 {
        MSG_ID_RPC_FORWARD_MESSAGE_B_REQUEST
    }
}

impl MessageId for super::cluster::RpcForwardMessageBResponse {
    fn msg_id(&self) -> u16 {
        MSG_ID_RPC_FORWARD_MESSAGE_B_RESPONSE
    }
}

impl MessageId for super::cluster::RpcForwardMessageBNotify {
    fn msg_id(&self) -> u16 {
        MSG_ID_RPC_FORWARD_MESSAGE_B_NOTIFY
    }
}

impl MessageId for super::common::BaseMessage {
    fn msg_id(&self) -> u16 {
        MSG_ID_BASE_MESSAGE
    }
}

impl MessageId for super::common::SerialMessage {
    fn msg_id(&self) -> u16 {
        MSG_ID_SERIAL_MESSAGE
    }
}

impl MessageId for super::session::LoginFRequest {
    fn msg_id(&self) -> u16 {
        MSG_ID_LOGIN_F_REQUEST
    }
}

impl MessageId for super::session::LoginFResponse {
    fn msg_id(&self) -> u16 {
        MSG_ID_LOGIN_F_RESPONSE
    }
}

impl MessageIdSerialize for super::chat::ChatTestBRequest {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::chat::ChatTestBResponse {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::cluster::ServerConfig {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::cluster::NodeRegisterBRequest {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::cluster::NodeRegisterBResponse {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::cluster::NodeConnectBRequest {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::cluster::NodeConnectBResponse {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::cluster::NodeRegisterBNotify {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::cluster::RpcMessageFRequest {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::cluster::RpcMessageFResponse {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::cluster::RpcMessageFNotify {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::cluster::RpcForwardMessageBRequest {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::cluster::RpcForwardMessageBResponse {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::cluster::RpcForwardMessageBNotify {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::common::BaseMessage {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::common::SerialMessage {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::session::LoginFRequest {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

impl MessageIdSerialize for super::session::LoginFResponse {
    fn serialize_to_buffer(&self) -> Result<bytes::BytesMut, Box<dyn std::error::Error + Send + Sync>> {
        // Get message ID
        let msg_id = self.msg_id();
        
        // Encode message using prost
        let mut data = Vec::new();
        self.encode(&mut data)?;
        let data_len = data.len();
        
        // Create buffer with exact size needed (2 for msgid + 2 for length + data)
        let mut buffer = bytes::BytesMut::with_capacity(2 + 2 + data_len);
        
        // Write message ID (big-endian)
        buffer.extend_from_slice(&msg_id.to_be_bytes());
        
        // Write length as u16 (big-endian)
        buffer.extend_from_slice(&(data_len as u16).to_be_bytes());
        
        // Write message data
        buffer.extend_from_slice(&data);
        
        Ok(buffer)
    }
}

/// Message decoding factory
pub struct MessageFactory;

impl MessageFactory {
    /// Decode ChatTestBRequest from DynamicBuffer
    pub fn decode_chat_test_b_request(buffer: &mut DynamicBuffer, length: usize) -> Option<super::chat::ChatTestBRequest> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::chat::ChatTestBRequest::decode(&data[..]).ok()
    }

    /// Decode ChatTestBResponse from DynamicBuffer
    pub fn decode_chat_test_b_response(buffer: &mut DynamicBuffer, length: usize) -> Option<super::chat::ChatTestBResponse> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::chat::ChatTestBResponse::decode(&data[..]).ok()
    }

    /// Decode ServerConfig from DynamicBuffer
    pub fn decode_server_config(buffer: &mut DynamicBuffer, length: usize) -> Option<super::cluster::ServerConfig> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::cluster::ServerConfig::decode(&data[..]).ok()
    }

    /// Decode NodeRegisterBRequest from DynamicBuffer
    pub fn decode_node_register_b_request(buffer: &mut DynamicBuffer, length: usize) -> Option<super::cluster::NodeRegisterBRequest> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::cluster::NodeRegisterBRequest::decode(&data[..]).ok()
    }

    /// Decode NodeRegisterBResponse from DynamicBuffer
    pub fn decode_node_register_b_response(buffer: &mut DynamicBuffer, length: usize) -> Option<super::cluster::NodeRegisterBResponse> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::cluster::NodeRegisterBResponse::decode(&data[..]).ok()
    }

    /// Decode NodeConnectBRequest from DynamicBuffer
    pub fn decode_node_connect_b_request(buffer: &mut DynamicBuffer, length: usize) -> Option<super::cluster::NodeConnectBRequest> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::cluster::NodeConnectBRequest::decode(&data[..]).ok()
    }

    /// Decode NodeConnectBResponse from DynamicBuffer
    pub fn decode_node_connect_b_response(buffer: &mut DynamicBuffer, length: usize) -> Option<super::cluster::NodeConnectBResponse> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::cluster::NodeConnectBResponse::decode(&data[..]).ok()
    }

    /// Decode NodeRegisterBNotify from DynamicBuffer
    pub fn decode_node_register_b_notify(buffer: &mut DynamicBuffer, length: usize) -> Option<super::cluster::NodeRegisterBNotify> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::cluster::NodeRegisterBNotify::decode(&data[..]).ok()
    }

    /// Decode RpcMessageFRequest from DynamicBuffer
    pub fn decode_rpc_message_f_request(buffer: &mut DynamicBuffer, length: usize) -> Option<super::cluster::RpcMessageFRequest> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::cluster::RpcMessageFRequest::decode(&data[..]).ok()
    }

    /// Decode RpcMessageFResponse from DynamicBuffer
    pub fn decode_rpc_message_f_response(buffer: &mut DynamicBuffer, length: usize) -> Option<super::cluster::RpcMessageFResponse> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::cluster::RpcMessageFResponse::decode(&data[..]).ok()
    }

    /// Decode RpcMessageFNotify from DynamicBuffer
    pub fn decode_rpc_message_f_notify(buffer: &mut DynamicBuffer, length: usize) -> Option<super::cluster::RpcMessageFNotify> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::cluster::RpcMessageFNotify::decode(&data[..]).ok()
    }

    /// Decode RpcForwardMessageBRequest from DynamicBuffer
    pub fn decode_rpc_forward_message_b_request(buffer: &mut DynamicBuffer, length: usize) -> Option<super::cluster::RpcForwardMessageBRequest> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::cluster::RpcForwardMessageBRequest::decode(&data[..]).ok()
    }

    /// Decode RpcForwardMessageBResponse from DynamicBuffer
    pub fn decode_rpc_forward_message_b_response(buffer: &mut DynamicBuffer, length: usize) -> Option<super::cluster::RpcForwardMessageBResponse> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::cluster::RpcForwardMessageBResponse::decode(&data[..]).ok()
    }

    /// Decode RpcForwardMessageBNotify from DynamicBuffer
    pub fn decode_rpc_forward_message_b_notify(buffer: &mut DynamicBuffer, length: usize) -> Option<super::cluster::RpcForwardMessageBNotify> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::cluster::RpcForwardMessageBNotify::decode(&data[..]).ok()
    }

    /// Decode BaseMessage from DynamicBuffer
    pub fn decode_base_message(buffer: &mut DynamicBuffer, length: usize) -> Option<super::common::BaseMessage> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::common::BaseMessage::decode(&data[..]).ok()
    }

    /// Decode SerialMessage from DynamicBuffer
    pub fn decode_serial_message(buffer: &mut DynamicBuffer, length: usize) -> Option<super::common::SerialMessage> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::common::SerialMessage::decode(&data[..]).ok()
    }

    /// Decode LoginFRequest from DynamicBuffer
    pub fn decode_login_f_request(buffer: &mut DynamicBuffer, length: usize) -> Option<super::session::LoginFRequest> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::session::LoginFRequest::decode(&data[..]).ok()
    }

    /// Decode LoginFResponse from DynamicBuffer
    pub fn decode_login_f_response(buffer: &mut DynamicBuffer, length: usize) -> Option<super::session::LoginFResponse> {
        // Check if we have enough data
        if buffer.readable_bytes() < length {
            return None;
        }

        // Read exact length of data from buffer
        let mut data = vec![0u8; length];
        let bytes_read = buffer.read_bytes(&mut data, 0, length);
        if bytes_read != length {
            return None;
        }

        // Decode using prost
        super::session::LoginFResponse::decode(&data[..]).ok()
    }

    /// Decode message by ID from DynamicBuffer
    pub fn decode_message(msg_id: u16, buffer: &mut DynamicBuffer, length: usize) -> Option<Box<dyn std::any::Any + Send>> {
        match msg_id {
            MSG_ID_CHAT_TEST_B_REQUEST => Self::decode_chat_test_b_request(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_CHAT_TEST_B_RESPONSE => Self::decode_chat_test_b_response(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_SERVER_CONFIG => Self::decode_server_config(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_NODE_REGISTER_B_REQUEST => Self::decode_node_register_b_request(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_NODE_REGISTER_B_RESPONSE => Self::decode_node_register_b_response(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_NODE_CONNECT_B_REQUEST => Self::decode_node_connect_b_request(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_NODE_CONNECT_B_RESPONSE => Self::decode_node_connect_b_response(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_NODE_REGISTER_B_NOTIFY => Self::decode_node_register_b_notify(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_RPC_MESSAGE_F_REQUEST => Self::decode_rpc_message_f_request(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_RPC_MESSAGE_F_RESPONSE => Self::decode_rpc_message_f_response(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_RPC_MESSAGE_F_NOTIFY => Self::decode_rpc_message_f_notify(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_RPC_FORWARD_MESSAGE_B_REQUEST => Self::decode_rpc_forward_message_b_request(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_RPC_FORWARD_MESSAGE_B_RESPONSE => Self::decode_rpc_forward_message_b_response(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_RPC_FORWARD_MESSAGE_B_NOTIFY => Self::decode_rpc_forward_message_b_notify(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_BASE_MESSAGE => Self::decode_base_message(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_SERIAL_MESSAGE => Self::decode_serial_message(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_LOGIN_F_REQUEST => Self::decode_login_f_request(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            MSG_ID_LOGIN_F_RESPONSE => Self::decode_login_f_response(buffer, length).map(|m| Box::new(m) as Box<dyn std::any::Any + Send>),
            _ => None,
        }
    }
}
